eztfl-html5 thoughts			Alistair Mann
==============================================================================

2017-04-20 14:30
Following on from the eztfl website (http://eztfl.pectw.net) where I recreated
the original TFL Countdown benefits in a pure html site, I discover another
scratch to itch: I want the site to tell me what bus stops are in front of me
given my position and location.

The original site was specifically created to be purely server-side but
particularly fast. However geolocation - the technology required to for
this new purpose - is client-side; further, the user would be specifically
trading processing speed for application intelligence: he wants to know
what his options Will Be, not What They Are. As this is diametrically
opposed to the original site's design goals, it's warranted we start an
whole new project instead.

The second thing a project needs, after the itch to scratch, is a name. The
original name was "eztfl", the new project will rely on html5 principles,
so how about we use eztfl-html5. There! That took all of a few seconds.

It looks like I'll be doing this publically as well, so I'll start recording
development (in this file, "eztfl-html5 thoughts") and a diary ("eztfl-html5
diary")

Project goals in depth.
eztfl.pectw.net answers the question: "I'm at bus stop X. What are my options?"
eztfl-html5 is to answer the question: "I'm at X, Y walking in direction Z. What
are my options?"
I'm interested in creating this not as an app (of which there are plenty) but
as a website. This has a far lower barrier to entry than creating apps (Which
includes $100+ for distributing Android or iOS apps, plus cost of powerful
machinery; where website development & distribution can be free.) More
importantly, support for browsers would logically be more extensive than
support for apps: an old and cheap phone would likely support html and
javascript better than it could support a modern app.

2017-04-20 14:55
Introducing TFL.
The task here is about London, England and her famous red buses. Public
transport is handled by TFL - Transport for London - who have a very
enlightened approach to their data, including a RESTful API for obtaining
"Countdown" info: which buses are arriving at any given bus stop in the
next 30 minutes.

Introducing me as dev and the tools I'll use.
I've been programming since 1979 including games, financial sector software
and business software. I find myself in posession of a public-facing website,
domains, DNS control and SSL certificates which means I can put most things
up. I've written server-side software before, more recently using PHP. I've
also written websites in html and html5, and client-side software most
recently using Javascript. I've connected the client-side to the server-side
and back again using AJAX principles. I've also connected clients to servers
using RESTful principles, although I may not need them here. Finally, I've
also done some work in securing software, so I'll look to bake that in as
we go.

So we'll see a 'stack' that looks like this:

client: HTML5/CSS
	JavaScript
	    ^
	    | (Maybe RESTful)
	    V
Server: PHP
	    ^
	    | (Definitely RESTful)
	    V
TFL:    API

Constraint: HTTPS
I happen to know beforehand that geolocation requires the use of HTTPS from
Chrome v50 released around April 2016. I'll look to honour that even if the
browser used is not Chrome, so using HTTPS is an immediate constraint.
2017-04-20 15:18

2017-04-20 20:45
As I'm wanting to do this publicaly, it's appropriate to put this stuff on
github. I already have one, so what I got so far can go there

2017-04-20 21:00
That only took a few minutes :-) Existing project now found at:
     https://github.com/Csi18nAlistairMann/eztfl-html5
Upto the github migration I was the Kate Editor
(https://kate-editor.org/about-kate/) for basic text editing. Now I'm in a
local repository of this as github project, I'm using emacs on the command
line - my usual preference when programming.
     I'm not used to github. In fact I'm not used to much of git, so spent
some faffing these documents into an acceptable upload.
     Also annoying is having to add un/pw pair for each github exchange. I
thought I had added my ssh key already? Fix that too. Apparently not, so
upload muh public key to github, and test.
       So, even as a technical user, it sitll took me an hour to fully
migrate from two local files to a github (gh) project largely due to my
own limited understanding of git and gh
    1. create repo online
    2. clone it to local repo
    3. copy local text files to local repo
    4. faff with branch to upload
    5. faff with pull request and merge
    6. faff with un/pw in favour of key authentication
    7. faff with pulling back down
2017-04-20 21:44
Would be of interest to others to have a resources file. Create one at
      docs/eztfl-html5\ resources

Target platforms:
Now I know I mentioned earlier that the target isn't the device but the
browser. Despite that, it's worth you knowing what I'll be working with
here. ALL the hardware used for development of this project is old, at
least 2 years old. Where possible though, they are using the latest
freely available software. I want to push that one doesn't have to spend
alot to develop!
That said, their geolocation capabilities are not yet known. We'll come
to that shortly.

2017-04-20 22:06
	  It's worth mentioning that there are some things I don't care
about for this project. One is the css displayport. It's incidental to
the purpose of this project that it fits perfectly on the screens of
arbitrary devices. As such, I'll assume a resolution of 1136x640.
	  It's also obvious now that I'm building a picture of What
The Project will look like, and that's in part dependent on what I have
to hand, and what I know. A new file is coming that describes that
at that date, rather than the organic description in here. We'll call it
docs/Goals
	I'll also rename this, the diary and the resources file. Having
eztfl-html5 in the name is redundant.
2017-04-20 22:34

Time for a tea.

2017-04-20 22:46
We aren't sure the project is achievable:
   At this point I don't know if my devices have hardware capable of
supporting success; I don't know if they do but lack JavaScript facilities
to assist. But then someone else doing exactly the same thing might
not have known geolocation wouldn't work without an https facility
so may fail because he couldn't afford/ configure one.
   The point is, there is a high degree of risk the project will have
to be abandoned. This is ameliorated by some research that will happen
first.

What constitutes project success?
     To start with, it may seem weird to define what success is when we
don't yet know whether we have what we need to reach the goal. However the
definition of success is plastic: when we know more about the goal, we can
in future what defines success. This is similar to a long drive: we might
choose to visit Alice & Bob and start by getting to their city before we
redefine success to getting to their neighbourhood, street and door. If
on the way we learn they're in the middle of Zombie outbreak, we might
reasonably redefine success to mean we'll visit Carol & David in a
different city instead. The trip will be a success, even if we don't end
up exactly where we first hoped.

   Consider the following diagram:

		   ._uvvvvnc,
		 _uv!~     ^?nc.
	       .ue~          -"S;
	      _d^ __i__.        4c.
	     <2~<oY^^"!1o,       "6.
	    .2<2"`      -Ya.      )c
	   .Jh?`          )nc      4;
	   )#^.___,         4;     -n.
	  .dCu3!""Yn;       =o.     )c
	  )#d^      4;       )c      S.
	  d#^       -4c       S.     );
	 _Q(          4;      )c     :C
	 ]F___,       :C       C      v
	 jk^ .";       n.      n.     3;
	 Q'    -c      );      );     =;
	 W      <      =;      =;     );
   A->Z  W  B   )  C    );  D   ); E   =;
	 W      )      =;      =;     =(
	 Q/    _^      j'      );     );
	 ]k,.._+      .z       v`     v`
	 ]m+""~       )(      .o     .o
	 -Wa.        =2       )(     =(
	  426.      <2`      .2      j'
	  =m)o_.  _se        )(     :e
	   3L-!1vn?^        :2      j'
	   :Q/             .J'     =e
	    )&a.          =d^     :2`
	     32nc.      _uY      .d'
	      ?u!1a___az?~      <2^
	       )o,~"""^       .<2
		-Ya_.       _v2"`
		  -!1o___i<z?^
		     ~""""^

In my mind, I have a user at position X, Y (A) walking in direction Z. In
a minute he'll be somewhere within range of B. A minute later, he could be
anywhere in range of C. After four minutes he could be anywhere in the
circle marking the range of E.

Knowing the location and radius of B, C, D, and E I imagine discovering
the bus stops within each and obtaining some basic data about them such
as direction of travel and bus routes stopping by, I then imagine
presenting these to the user in a list ordered by distance from A.

I imagine that this would answer the question above: "I'm at X, Y walking
in direction Z. What are my options?", and answering that question
constitutes project success.

There are degrees of leeway. What if I can't do circles, but can do pie
segments? That might be good enough. What if I can't calculate direction
can I take user guesses? (Think: "Are you moving North at 3mph?") That
might also be good enough. As I understand the technology further we may
redefine what consitutes project success.

2017-04-20 23:31

Is this project even possible?

A reasonable person should be able to look within themselves and identify
Known Knowns and Known Unknowns, in Donald Rumsfelds immortal words.
(https://en.wikipedia.org/wiki/There_are_known_knowns) It's a known that
I know html, php, ssh etcetera. It's an unknown that my equipment can
handle the project. Unknown Unknowns just have to await uncovering.

So the task is to list Known Unknowns for the first stage of the project:
Make the Unknowns Known, and adjust the project to suit. For eztfl-html5
my Known Unknowns are:

1. Can I have JavaScript capture:
   a: position
   b: direction of travel
   c: speed of travel
2. Can this capturing work on available devices:
   a. LG G2
   b. iPhone 5s
   c. iPad Air 2
   d. a standard desktop browser
3. Can this data be used to calculate likely ranges for future positions
4. Can these ranges be used to interrogate the TFL API
5. Given the answers above, should project goals be revisited?

2017-04-20 23:45

Notice that so far I have written:
   31    71   513 Resources
   31   186  1253 Diary
  239  1696 10397 Thoughts
   21   114   731 Goals
    1     1     3 .gitignore
  323  2068 12897 total

12kb of files, including 2000 words across 323 lines with ZERO code.

2017-04-20 23:54

Plan for handling Known Unknowns.
1. Questions of JavaScript capturing geolocation data is already known to be
   governed by HTTPS on Chrome. So before we issue JavaScript, we need an
   HTTPS domain to issue it from.
   Fortunately I have an existing catch-all cert for *.mpsvr.com, so I can
   start there:
   [x] Create https://eztfl-html5.mpsvr.com
     [x] DNS
     [x] Apache
2. The JavaScript to be issued appears at
   https://www.w3schools.com/html/html5_geolocation.asp with a strong
   suggestion from .latitude, .longitude, .heading and .speed are all
   available - if allowed on the device, and available from the hardware.
   [x] Recreate the JavaScript examples to answer the position, speed and
       heading question
3. Using the page just created, examine the response from the various
   devices to answer the second Known Unknown.
	   This got answered along the way - we know that iOS has the 65m
   problem, for instance.
4. What maths is needed to discover a possible position and radius using
   the above data? My very distant memory of writing 3D games (I never
   did, only looked into it when Original Doom came out in 1993) was that
   maths will likely involve sin, cos, tan, radians: trigonometry. Indeed
   a quick google suggests this might be a common question:
   http://stackoverflow.com/questions/2187657/calculate-second-point-knowing-the-starting-point-and-distance
   where we find cos and sin in the first answer.
	 [x] Frame the mathematical question for calculating position and
	     radius from position, speed and bearing
	 [x] Get maths
	 [x] Is this maths better done client-side or server-side?
5. Can the TFL API support position and radius for discovering what bus
   stops are nearby? The docs at:
   https://api.tfl.gov.uk/swagger/ui/index.html?url=/swagger/docs/v1#!/StopPoint/StopPoint_GetByGeoPoint
   say "Gets a list of StopPoints within {radius} by the specified criteria"
   which includes a radius default of 200m from location.lat, location.lon.
   This seems very likely what is needed.
   [x] How to interrogate above
6. [x] Reassess project in light of above answers.

Unknown Unknown #1: To set up Apache properly, I had to provide a server
admin email address.

2017-04-21 00:51

[x] Unknown Unknown #2: I have put a hello world page at
https://eztfl-html5.mpsvr.com but it will shortly contain code: how does
one handle that I want it to contain code that will be published at gh?
Can one set up a pull of only certain parts of the tree? How? Something
for tomorrow!

2017-04-21 11:19

Known Unknown #2: We now want JavaScript to indicate position, heading
and speed in a browser. We will also want to see that change as we go, so
the page will follow the three over time.
[x] Prove that we can obtain the data.
  We'll do this by copying in the example code.
	[x] Code with lat and lon works fine on G2
	[x] Extend to include accuracy, speed and heading
	Unknown Unknown #3: accuracy is available too
	[x] Speed and heading are both "null" on portable devices.
	    This may be because I'm walking around a room, but why is
	    it not "0"? Anwser: because the speed is not available at
	    all, not 0 because of an error

[x] Prove that we can follow the data. This is a trivial task so
    doesn't need proving.

Unknown unknown #4: "null" means not available, "undefined" is used for
	mispellings
	IDK if "null" also used for 0 speed and in what circumstances

2017-04-21 11:43

All these unknown unknowns might also be useful at other points in
the project as they're revealing behaviour that might fuel later
changes. To that end I've started collecting them in
docs/UnknownUnknowns

Unknown unknown #5: documentation and testing thus far suggests that
speed and heading are not always available. It occurs to me that the
project could use a timed succession of co-ordinates to extrapolate
both

2017-04-21 12:11

I'm stymied by the availability or otherwise of actual heading and
speed data from my devices - they all report null from just walking
about. So I'm off to sit on a bus and let it do the work.

2017-04-21 13:00

About 15 minutes actual work.
I didn't get on the bus as the target of the project is users walking
towards bus stops, so I walked instead of rode.
None of the portable devices gave heading and speed at any point.
Unknown unknown #6: The iPhone 5s and iPad did not give an accuracy
below 65m at any point. Adding credit to it's account made no difference
too.

It would seem that either:
+ none of my hardware natively reports speed and heading;
+ speed and heading is not reported by the hardware but tracked by
  the software and uu2.html doesn't activate that feature;
At worst, I'll still have the manual backup.
It would seem to be the first. When trying
https://www.audero.it/demo/geolocation-api-demo.html
speed and heading are both correct on a borrowed LG LV2 & a
Samsung Galaxy J5, both recent devices. The same page offers nothing
for my devices. To proceed, then, means to create the manual alternative
for my own devices as a fall back for newer devices not being present.
Unknown unknown #7: code to support old phones, or abandon them.

2017-04-21 13:49

Unknown unknown #7: code to support old phones, or abandon them.
Knowing that at Time T1 the position was X1, Y1 and at T2 the position
changed to X2, Y2 what calculation gives us heading and speed?
Heading - as bearing - seems to be offered at
http://www.movable-type.co.uk/scripts/latlong.html
https://math.stackexchange.com/questions/1596513/find-the-bearing-angle-between-two-points-in-a-2d-space/
The former being more appropriate for huge distances, the second
better for far smaller distances. Let's calculate what answers we
should expect.
Using http://www.geomidpoint.com/destination/ to obtain:
Highbury & Islington tube station is 51.54647680000001, -0.10431170000003931
Arsenal's Emirates Stadium is at 51.5548885, -0.10843799999997827
At https://www.sunearthtools.com/tools/distance.php plugging those
coords in reports a bearing of 343.04deg.
Using https://www.google.co.uk to double check, we get a very similar
angle when looking 'by hand'. So we want:
bearing(51.54647680000001, -0.10431170000003931, 51.5548885, -0.10843799999997827) {
  ...
  return 343.04;
}

I'll copy uu2.html to uu7.html and modify the javascript to create
this function. This is pure lazyness - it saves me handling overhead
programming and coding as I'm reusing uu2.html's overhead. Once
done, we have code that should manually inform on bearing, proving
that Unknown Unknown #7 is in part addressable before project continues.

Looking at the code I see a constant TWOPI: 6.2831853071795865. Is this
number associated with this kind of work? It's certainly PI * 2 and
googling "6.2831853071795865 bearing" does seem to bring up references
to this constant for this work. The second constant, RAD2DEG also
googles up for quite a bit of use with radians and degrees. So I don't
know how this second constant is arrived at, or how either were
originally worked out, but I'm happy I don't need to in order to use
their properties effectively. This completes the due diligence that
the routine being used is likely to be effective.

At first blush it looks like the code provided accepts coords in the
double form provided. Let's run and see.
1. Doesn't work move script to <head /> and retest
2. Doesn't work. F12 to see error in alert() use. Fix and retest
3. Doesn't worl. F12 to see atan2 not defined. Change to Math.atan2
   and retest
4. Wrong answer: get 63.870066427646954 when expected 343.04. Adding
   both is 406, so this isn't just going the wrong way around the
   clock that would be expected if the answer was 360.
5. Could this be me providing arguments in the wrong order?
   C++, the example code has atan2 given y, then x.
   Check shows I've not changed argument order.
6. I notice warning that in the example, Y increases the further
   down one goes. Could it be that I need to invert Y?
   Change sign of both Y arguments and retest. Get result
   116.12993357235304, so not because Y needed sign changing.
7. That makes me think that this example code was not appropriate
   to this task. Either I don't understand the task, or I don't
   understand the example.

Googling some more I come across:
https://gis.stackexchange.com/questions/29239/calculate-bearing-between-two-decimal-gps-coordinates
Using it as a drop-in replacement I get the answer 343.0366983003317
which is perfect.

What's happened here is that I'm treating the code as a Black Box.
I don't know, nor need to know how it works (other than due
diligence that it's not going to be malign), I just need to know
that it does work when called.

I'll invent a second test.
Sydney Opera House is at -33.858667, 151.214028 according to
Wikipedia and confirmed at maps.google.com. The nearby attraction
Mrs Maquarie's Chair, is at -33.859467, 151.222203. What's the
bearing? It looks like 120deg to me. Plugging the coords in
I get 96.72099553985117 which is some way off. Maybe I got the
coords wrong? No. The coords provided by Wiki are someway South
and North of what the map appears to show, and 96deg does seem
accurate. Let's check both back at
https://www.sunearthtools.com/tools/distance.php where we expect
a similar answer. We get 96.72deg.

So the code to get the bearing manually, found in uu7.html and
shamlessly ripped off of Francisco Valdez at the above SE link
is sufficient to resolve that part of Unknown Unknown #7.

2017-04-21 15:07

The second part is to manually determine speed. There would seem
to be a very similar algorithm: look at the distance covered by
the two points then divide by the time taken to travel it. So:
distance(x1, y1, x2, y2){
  return meters
}
speed(meters, seconds){
  return meters-per-second
}
The first as an SE link at
http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula

Dropping it in to uu7.html and with the examples above I get
a distance of 0.9778843260636695km and 0.7600819724022814km
respectively when I was expecting a result of 978.2m and 760.3m
so the code is right on the money again.

Knowing the meters travelled and the seconds taken, it's trivial
to calculate the meters-per-second for speed so I'll take those
as given and conside Unknown Unknown #7 addressed.

Unknown Unknown #3 gets an update: we have code to manually
calculate heading and speed if required.

Unknown Unknown #5 gets an update: we have code to manually
calculate heading and speed if required.

Unknown Unknown #7 gets an update: we have code to manually
calculate heading and speed if required.

2017-04-21 15:28

2017-04-21 15:45
Unknown Unknown #2: What configuration sees the server only
retrieve certain files from github

My objective here is that the files on the server are also
available through gh. However, I do not want any but specific
files to be available. What to do?

2017-04-21 15:50

2017-04-21 17:05

In the normal course of events, I would hold the development tree
on a development machine. Updates would be run through unit tests
and once accepted pushed out to a Gold machine with a non-visible
account and a batch file that copies live code from the repo
into place in the visible account.

This is not that kind of a project though. Instead, I'll copy
live code on the server into test file and edit it in updates
there. Should the edits be good, the files get swapped around.
If not, they get deleted.

This can be done because the project is not "live" in the sense
the public is using it.

As development is being done on a live server, even if not the
final live server, the connection to gh can be done instead as a
pull: develop on the server -> test on a device -> scp files to
development machine repo -> push to gh.

So let's add the hello world index file and two Unknown Unknowns
files we've create thus far.

2017-04-21 17:05

One may notice that I've created a bash script to sync the local
repo with the development server. .gitignore skips it though, as
it's developer dependent - other devs wouldn't need access to it.

This solves Unknown Unknown #2.

I've now created:
   64   407  2726 docs/Diary
   21   114   731 docs/Goals
   37    79   573 docs/Resources
  521  3665 22706 docs/Thoughts
   40   183  1315 docs/UnknownUnknowns
    7     8    57 server-code/index.html
    2     4    63 server-code/sync.sh
   49   125  1284 server-code/uu2.html
   84   226  1977 server-code/uu7.html
  825  4811 31432 total
825 lines and 31kb of text for this project and I've still not
laid down any code of my own other than a hello world holder
page. In fact from:
   7    8   57 index.html
  49  125 1284 uu2.html
  84  226 1977 uu7.html
 140  359 3318 total
We see that of the 140 lines of runnable code - as html or javascript,
almost all of it has been co-opted from examples at Stack Exchange
with perhaps the odd line or two done by me.

2017-04-21 17:57

Known Unknown #4: frame the maths needed to discover position and
range. The intent here is that we use the position, heading and speed
to work out where we'll be in some short period.

One thing to get right to is that logically I no longer need to do
the very beautiful circles thing above - I only need to solve for
the final circle, E. By using a function that returns the distance,
I'm able to solve for E, then use that distance function to work out
how far each in E is from the starting point, A. By then ordering
the responses by distance, I answer the question posed as consituting
project success: "I'm at X, Y walking in direction Z. What are my
options?"

I only need to solve E. The maths would seem simple: Given my position,
speed and heading, calculate where I'll be in (say) 90 seconds. Given
my speed, estimate the distance I could cover in an additonal (say)
45 seconds.

2017-04-21 19:59
To calculate likely position I would need to know the heading and
distance likely travelled from some origin.
The distance can be discovered from meters-per-second (aka mps, about
1.3mps according to Google, for the average man.)
mps can be calculated with the SE code from knowing where we are, and
where we were.
Unknown Unknown #8: More accurately accounting for location. Rather
than taking one reading at start and another at end, take readings all
along the way? Apply best fit analysis? This technique could be used
to later improve what we're doing.
Client opens web site and approves geo use.
JS obtains readings
With two or more readings, and using the most recent reading, calculate
the position we'll reach given existing heading and speed.
Use distance to establish where we will be
Use speed to calculate our radius from that point

A ----> B -----> C -----> D

A = Page is opened, first position obtained (x1, y1)
B = Most recent reading (x2, y2)
C = Guess of where we'll be in (90) seconds (x3, y3)
D = Guess how far we can travel in (30) seconds (in meters)

In particular note that C = guessFrom(A, B) is not to suggest guessFrom
should ONLY be using two values, rather that A, B forms an array of
two or more values. So: C = guessFrom(AB[A, a1, a2, a3, ..., an, B])

The remainder of this looks trivial, so I'm going close the first two
Known Unknown #4 elements off.

Is this maths better done client-side or server-side? Client-side, it must
be: with JavaScript heralded as a games platform, with devices using 3D
rendering, the cost of sending maths off-device must be enormous and only
getting worse.

Note: this question only rises because I have little idea about the maths
involved in the SE code and its relative processing expense. What I do
have insight about is the processing expense of network connections
(>Thousands of times slower) and floating point work (about 10x worse than
equivalent ints if I remember my 80386 clock cycles correctly.) As the
SE code chains 10-15 maths functions together, then on the face of it
even "150x slower" vs ">1000s" slower still makes more sense.

So: this maths is better done client-side. How much better is less
important.

2017-04-21 20:49
Known Unknown #5: can the TFL API support position and radius for
discovering what stops are nearby? Yes: taking lat, lon and radius.
https://api.tfl.gov.uk/swagger/ui/index.html?url=/swagger/docs/v1#!/StopPoint/StopPoint_GetByGeoPoint
A GET request to the given URL returns a JSON response which on the
example I've seen does return data about bus stops.

This only took a few mins to write, but I knew the above link from
a while back - indeed, it was one of the reasons I thought this
project might already be a goer. If I hadn't know about it, it might
have taken some time to discover it.

2017-04-21 20:59
Known Unknown #6: Reassess project in light of answers to
known unknowns and unknown unknowns.

I started yesterday with an idea: that I want a site to give me bus
stop options on my way towards a location.

I start off with a certain variety of resources both public and personal,
physical and intangible. It most certainly helps that I have equipment
and skills, and that I've already much of the overhead work when
creating my original eztfl.pectw.net site.

In the first phase I got down some description of what the idea is
about, how it would likely work, and what would constitute success.

In the second phase I started looking instead at what I didn't know:
the Known Unknowns - Things that I know I don't know, such as whether
my equipment is up to the job - and Unknown Unknowns - Things that
will impact the project but I haven't guessed ahead of time. Knowing
these are vital to reducing the risk associated with timing: the more
I know about what I'm doing, the less likely I'll be suprised.

In order to address these Unknowns, I formed lists of both as I went
along, and addressed each in turn until a short while ago all
outstanding points had been examined.

In proceding, some considerable overhead work has been started anyway:
Starting a github resource where what I've done so far can be found;
setting up DNS and Apache to support HTTPS connections; IRL work
walking around examining what devices were reporting. It'd be fair
to guess I've spent a bit more than a day of time investihating the
Unknowns, setting things up to answer them - things which are
identical to those I might have later done had I plunged in without
this preliminary work. So far I've spent no money (or at least, no
money I wouldn't have spent anyway) so the investment is minor.

In investigating the Unknown Unknowns I recognise that some aspects
of how I imagined the project need modifying. These are:

1. [x] Accuracy is an input into the site. I may choose that the
   site does different things at a lower accuracy than ideal. This
   can safely left to the Todo.

2. That older equipment doesn't offer heading and speed, however
   both those can be calculated by the project rather than obtained
   from the hardware via the OS.
   This will add a small amount of more time, but not much.

3. That the stack changes to:

client: HTML5/CSS <---(Definitely RESTful)-------> TFL: API
	JavaScript
	     ^   |
	     |  ++--------------------------------------
	     | / |(Maybe RESTful)
	     V | V
Server: PHP +--+                      Optional to implementation
	   / ^
----------+  |(Definitely RESTful)
	     V
TFL:    API

	Where note the client can themselves directly obtain such data
as they require from TFL. This would obviously be faster (as not
intermediated through my server) on the upside. On the downside, such
connections are more heavily shaped given it would be sans the APIKey.
There's the option of implementing via the server but I can't
immediately think of a reason why I'd want to.
	    This informs where the work is done. Answer: in the
browser.

4. That instead of seeking responses from increasing circles drawn
around where the user will likely be, it'll be sufficient to draw
from the largest of them and order by distance from the origin:

				    \
[A1, A2, A3, ..., An] -----> B --C--->
				    /

Where:
[A1 to An] are two or more sets of lat, lon coords in an array
    of readings of the position since the page was open
B is the lat, lon position those readings suggest the user will
  arrive at (docs suppose 90 seconds time, but that can be a choice
  left til later)
C is the radius in meters from B the user can get to given a certain
  amount (docs suppose 45 seconds) of time

  This informs the design of the program in terms of collecting
data and using it from history rather than naively using first and
whatever last lat, lon was and is.

Given these four, the definition of project success doesn't need
to be changed from "I'm at X, Y walking in direction Z. What are my
options?"

2017-04-21 22:16
Phase 3: implementation.

Now we know that the idea is doable with a much lowered risk that
something unknown will cause problems, it's time to consider what
to code.

Before we start note that:
   73   457  3065 Diary
   21   114   731 Goals
   37    79   573 Resources
  732  5191 31686 Thoughts
   12    84   534 Todo
   42   211  1500 UnknownUnknowns
  917  6136 38089 total
I have written 917 lines, 6000 words and 38kb on the project and
ZERO CODE code except to test
   7    8   57 index.html
   2    4   63 sync.sh
  49  125 1284 uu2.html
  84  226 1977 uu7.html
 142  363 3381 total
142 lines of code taken from Stack Exchange. A considerable amount
of knowledge has gone into configuring things, however.

What will the code Look Like? If we wanted a vehicle, we might fit
what we bought to the purpose: an 18 wheeler to haul vegetables,
a 1969 Dodge Charger to haul ass. Likewise with source: ours is not
going to be the earnest mouse of a batch script conveying an input
through to output. Nor is ours to be the matador of a RESTful server
dancing to avoid the garbage anyone from anywhere could be driving
at it. Nope: eztfl-html5 will be most like a computer game: it
starts when it does, it ends when it does, and between the two it
will thump away like a factory, updating, sending to screen, and
repeat.

Like a computer game, we'll have a Main Loop to which control 
always eventually returns. Before the Main Loop is always such set
up as is needed. There'll be nothing after the Main Loop, as 
there is no "after" that needs to be addressed: once the browser
window is closed, the browser itself will handle such clean ups
as are needed.

The Main Loop in this project is passed as a callback to 
geolocation.watchPosition() - whenever the position updates, the
Main Loop is restarted. (This neatly avoids using GOTO start!)

This represents the core of the project. We now proceed to define
what the Main Loop should do each time its run.

The Main Loop should retrieve the current geolocation data and
store it. When two or more are available, they are used to make a
prediction about the future. When a prediction is available and
different to the last prediction, it's used to update the display.
The Main Loop then ends.

Notice we don't say anything here about the user interface, or the
user experience. That's because at this point, it doesn't actually
matter. We might just put straightfoward text. We might have 
rambling zombie icons on the screen. We might demonstrate what we
have as a colour map. None of these choices need be made yet (or
even by us, in larger projects.) Our purpose for the moment is
simply to correctly process the input such that output has 
something to work with.

We do want to know that things are working, however, so we'll add
a debug facilty in: we'll print out the inbound data, so as user
we can see things are progressing (although we could equally use
the developer tools, they're less convenient on portable devices
which is - after all - the target market.)

We have enough now to get going. We'll call this 
server-code/a.html
1. Get an empty HTML5 present
2. Get JavaScript running at start up
